# -*- coding: utf-8 -*-
"""OTUS_Lesson_3_loops_and_conditions_ipynb_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jRubWw3BjY0XiBuHdzJk-lIlgzJaC8wo

# Занятие: Управление потоком

## Цели занятия

- Рассмотреть конструкции для управления потоком: оператор ветвления и циклы
- Разобраться с тонкостями использования операторов ветвления и циклов
---

## 1. Введение

### 1.2. Значение управления потоком в программировании

#### Почему важно уметь контролировать выполнение программы

В программировании **управление потоком** (flow control) позволяет определять порядок выполнения инструкций в программе. Без механизмов управления потоком программа бы выполняла инструкции строго по порядку сверху вниз, что ограничивает её функциональность и гибкость. Рассмотрим, почему управление потоком является ключевым элементом в создании эффективных и полезных программ.

#### Основные причины важности управления потоком:

1. **Принятие решений**:
   - Позволяет программе реагировать на разные условия и выбирать, какой путь выполнения следует выбрать.
   - Например, программа может проверить, является ли введенное пользователем число положительным или отрицательным, и выполнить соответствующие действия.

2. **Повторение действий**:
   - Позволяет повторять определенные действия несколько раз без необходимости писать один и тот же код многократно.
   - Это особенно полезно, когда количество повторений заранее неизвестно или зависит от условий во время выполнения программы.

3. **Улучшение читаемости и поддерживаемости кода**:
   - Позволяет структурировать программу логически, делая её более понятной для других разработчиков и для самого автора в будущем.
   - Четко организованный поток выполнения облегчает отладку и расширение функциональности программы.

4. **Эффективность и производительность**:
   - Позволяет оптимизировать выполнение программы, избегая ненужных вычислений и операций.
   - Например, выход из цикла при достижении нужного результата экономит ресурсы и время выполнения.

#### Примеры важности управления потоком

**Пример 1: Проверка возраста пользователя**

Предположим, мы пишем программу, которая проверяет, имеет ли пользователь право на доступ к определенному контенту.
"""

age = int(input("Введите ваш возраст: "))

if age >= 18:
    print("Доступ разрешен.")
else:
    print("Доступ запрещен.")

"""
В этом примере оператор `if-else` позволяет программе принять решение на основе введенного возраста и выполнить соответствующее действие.

**Пример 2: Подсчет суммы чисел до определенного значения**

Допустим, нам нужно вычислить сумму всех чисел от 1 до 10.

Без использования циклов нам пришлось бы писать:"""

sum_nums = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
print("Сумма:", sum_nums)

"""Однако при использовании цикла `for` это можно сделать более эффективно:"""

sum = 0
for i in range(1, 11):
    sum += i
print("Сумма:", sum)

"""Цикл `for` делает код более гибким и удобным, особенно если диапазон чисел изменится.

---

Управление потоком является фундаментальной концепцией в программировании, которая позволяет создавать динамичные и адаптивные программы. Понимание и умение применять конструкции управления потоком, такие как операторы ветвления и циклы, открывает широкие возможности для разработки сложных и эффективных приложений.

В следующих разделах мы подробно рассмотрим различные конструкции управления потоком, их синтаксис, примеры использования и лучшие практики. Это позволит вам эффективно контролировать выполнение ваших программ и создавать более сложные и функциональные приложения.

## 2. Оператор ветвления `if`, `elif`, `else`

Операторы ветвления позволяют программе принимать решения и выполнять различные участки кода в зависимости от заданных условий. В Python основными конструкциями для управления потоком выполнения на основе условий являются `if`, `elif` и `else`.

### 2.1. Синтаксис оператора `if`

Оператор `if` используется для проверки условия. Если условие истинно, выполняется блок кода внутри `if`.

**Структура оператора `if`:**

```python
if условие:
    # Блок кода выполняется, если условие истинно
    действие
```

**Пример 1: Проверка положительности числа**

Пример показывает, как использовать оператор `if` для проверки, является ли число положительным:
"""

number = int(input('Введите число:\n>>> '))

if number > 0:
    print("Число положительное.")

"""

### 2.2. Использование `else`

К оператору `if` можно добавить `else`, который выполняется, если условие `if` ложно.

**Структура `if-else`:**

```python
if условие:
    # Блок кода выполняется, если условие истинно
    действие
else:
    # Блок кода выполняется, если условие ложно
    альтернативное действие
```

**Пример 2: Проверка чётности числа**

Пример демонстрирует использование `if-else` для определения, чётное число или нет:"""

number = int(input('Введите число:\n>>> '))

if number % 2 == 0:
    print("Чётное число.")
else:
    print("Нечётное число.")

"""
### 2.3. Использование `elif`

Конструкция `elif` (сокращение от "else if") позволяет проверять дополнительные условия, если предыдущие условия оказались ложными.

**Структура `if-elif-else`:**

```python
if условие1:
    # Блок кода выполняется, если условие1 истинно
    действие1
elif условие2:
    # Блок кода выполняется, если условие1 ложно и условие2 истинно
    действие2
else:
    # Блок кода выполняется, если все предыдущие условия ложны
    альтернативное действие
```

**Пример 3: Определение оценки по баллам**

Пример показывает, как использовать `if`, `elif` и `else` для определения оценки на основе набранных баллов.
"""

score = int(input('Введите баллы:\n>>> '))

if score >= 90:
    print("Отлично")
elif score >= 70:
    print("Хорошо")
else:
    print("Нужно постараться")

"""
### 2.4. Вложенные операторы `if`

Вложенные операторы `if` позволяют создавать более сложные логические структуры, проверяя дополнительные условия внутри уже проверенных.

**Пример 4: Проверка возраста и наличия водительских прав**

Пример демонстрирует использование вложенных `if` для проверки нескольких условий.
"""

age = int(input('Введите возраст:\n>>> '))
has_license = bool(input('У вас есть права? (True/False):\n>>> '))

if age >= 18:
    if has_license:
        print("Вы можете управлять автомобилем.")
    else:
        print("Вам нужно получить водительские права.")
else:
    print("Вам ещё слишком мало для управления автомобилем.")

"""### Заключение

Операторы ветвления `if`, `elif` и `else` являются основными инструментами для принятия решений в программах. Они позволяют выполнять различные участки кода в зависимости от заданных условий, делая программы более гибкими и адаптивными к различным ситуациям.

---

## 3. Логические операции и таблица истинности

Логические операции позволяют комбинировать несколько условий для более сложных проверок. В Python основные логические операторы — `and`, `or`, `not`. Понимание их работы и приоритетов важно для создания правильных условий в программе.

### 3.1. Логические операторы

#### Оператор `and`

Оператор `and` возвращает `True`, если оба операнда истинны.

**Пример 1: Проверка двух условий**
"""

age = int(input('Введите возраст:\n>>> '))
has_license = bool(input('У вас есть права? (True/False):\n>>> '))

if age >= 18 and has_license:
    print("Вы можете управлять автомобилем.")

"""
#### Оператор `or`

Оператор `or` возвращает `True`, если хотя бы один из операндов истинен.

**Пример 2: Проверка хотя бы одного условия**
"""

day = input('Введите день недели:\n>>> ')

if day == "суббота" or day == "воскресенье":
    print("Сегодня выходной день.")
else:
    print("Сегодня будни.")

"""#### Оператор `not`

Оператор `not` инвертирует значение условия.

**Пример 3: Инверсия условия**
"""

is_raining = False

if not is_raining:
    print("Можно идти на прогулку.")

"""
### 3.2. Составные условия

Составные условия позволяют комбинировать несколько простых условий с использованием логических операторов для более сложных проверок.

**Пример 4: Проверка диапазона значений**
"""

temperature = int(input('Введите температуру на улице:\n>>> '))

if temperature > 20 and temperature < 30:
    print("Погода теплая.")

"""
### 3.3. Таблица истинности

Таблица истинности показывает результаты логических операций для всех возможных комбинаций входных значений.

**Таблица истинности для оператора `and`:**

| A     | B     | A and B |
|-------|-------|---------|
| True  | True  | True    |
| True  | False | False   |
| False | True  | False   |
| False | False | False   |

**Таблица истинности для оператора `or`:**

| A     | B     | A or B  |
|-------|-------|---------|
| True  | True  | True    |
| True  | False | True    |
| False | True  | True    |
| False | False | False   |

**Таблица истинности для оператора `not`:**

| A     | not A |
|-------|-------|
| True  | False |
| False | True  |

### 3.4. Примеры практического применения

**Пример 5: Проверка доступа на основе возраста и наличия документа**
"""

age = int(input('Введите возраст:\n>>> '))
has_permission = bool(input('У вас есть пропуск на вход? (True/False):\n>>> '))

if age >= 18 or has_permission:
    print("Доступ разрешен.")
else:
    print("Доступ запрещен.")

"""
**Пример 6: Определение категории по баллам**
"""

score = int(input('Введите баллы:\n>>> '))

if score >= 90:
    print("Отлично")
elif score >= 70 and score < 90:
    print("Хорошо")
else:
    print("Нужно постараться")

"""## 3.5. Тернарный оператор

Тернарный оператор позволяет записывать условные выражения в одной строке, делая код более компактным и читабельным. В Python тернарный оператор имеет следующий синтаксис:

```python
a if условие else c
```

Где:
- `условие` — логическое выражение, которое проверяется.
- `a` — значение, которое будет присвоено или возвращено, если `условие` истинно.
- `c` — значение, которое будет присвоено или возвращено, если `условие` ложно.

**Пример 7: Присваивание значения на основе условия**

**Задача:** Присвоить переменной `status` значение `"Взрослый"`, если возраст пользователя 18 или больше, иначе `"Несовершеннолетний"`.

"""

# Присваивание значения на основе условия с использованием тернарного оператора

age = int(input("Введите ваш возраст:\n>>> "))

status = "Взрослый" if age >= 18 else "Несовершеннолетний"

print(f"Статус: {status}")

"""
**Пример 8: Выбор значения для вывода**

**Задача:** Вывести сообщение о том, является ли число чётным или нечётным, используя тернарный оператор.
"""

# Определение чётности числа с использованием тернарного оператора

number = int(input("Введите число:\n>>> "))

result = "Чётное число." if number % 2 == 0 else "Нечётное число."

print(result)

"""
**Пример 9: Вложенные тернарные операторы**

**Задача:** Определить категорию возраста пользователя: `"Младенец"` (0-2), `"Ребёнок"` (3-12), `"Подросток"` (13-17), `"Взрослый"` (18 и больше).
"""

# Определение категории возраста с использованием вложенных тернарных операторов

age = int(input("Введите ваш возраст:\n>>> "))

category = "Младенец" if age <= 2 else ("Ребёнок" if age <= 12 else ("Подросток" if age <= 17 else "Взрослый"))

print(f"Категория возраста: {category}")

"""Тернарный оператор `a if b else c` позволяет упростить записи простых условных выражений, делая код более компактным. Однако, при использовании вложенных тернарных операторов следует быть осторожным, чтобы не ухудшить читаемость кода. В таких случаях лучше использовать традиционные конструкции `if-elif-else`.

### Заключение

Логические операции играют важную роль в создании сложных условий и управлении потоком выполнения программы. Понимание операторов `and`, `or`, `not`, а также таблиц истинности позволяет писать более точные и эффективные условия, что повышает качество и надежность кода.

## 4. Работа с циклом `while`

Циклы позволяют выполнять определённые участки кода многократно, пока выполняется заданное условие. В Python цикл `while` выполняет блок кода, пока условие истинно. Это особенно полезно, когда количество итераций заранее неизвестно и зависит от условий во время выполнения программы.

### 4.1. Синтаксис цикла `while`

Цикл `while` состоит из условия и блока кода, который выполняется, пока это условие истинно.

**Структура цикла `while`:**

```python
while условие:
    # Блок кода, выполняемый при истинности условия
    действие
```

**Пример 1: Подсчёт до введённого пользователем числа**

В этом примере программа запрашивает у пользователя число и выводит все числа от 1 до введённого значения.
"""

max_number = int(input("Введите число до которого нужно считать:\n>>> "))
current = 1

while current <= max_number:
    print(current)
    current += 1

"""### 4.2. Управление циклом

Управление циклом включает использование счётчиков, инкрементацию и предотвращение бесконечных циклов.

**Пример 2: Суммирование чисел до введённого пользователем значения**

Программа запрашивает у пользователя число и вычисляет сумму всех чисел от 1 до этого числа.
"""

max_number = int(input("Введите число для суммирования:\n>>> "))
current = 1
total_sum = 0

while current <= max_number:
    total_sum += current
    current += 1

print("Сумма чисел от 1 до", max_number, "равна", total_sum)

"""
### 4.3. Операторы `break` и `continue`

Операторы `break` и `continue` позволяют управлять потоком выполнения внутри цикла. `break` прерывает цикл полностью, а `continue` пропускает текущую итерацию и переходит к следующей.

**Пример 3: Поиск числа с прерыванием цикла**

Программа запрашивает у пользователя числа до тех пор, пока не будет введено число 0, после чего цикл прерывается.
"""

while True:
    number = int(input("Введите число (0 для выхода):\n>>> "))
    if number == 0:
        print("Цикл прерван. Завершение программы.")
        break
    print("Вы ввели:", number)

"""
**Пример 4: Пропуск нечётных чисел**

Программа выводит только чётные числа от 1 до 10, пропуская нечётные.
"""

current = 1

while current <= 10:
    if current % 2 != 0:
        current += 1
        continue
    print(current, "— чётное число")
    current += 1

"""
### 4.4. Бесконечные циклы

Бесконечные циклы продолжаются бесконечно, пока не будут прерваны внешним условием, например, оператором `break`. Они полезны в случаях, когда программа должна постоянно ожидать ввода от пользователя или работать как сервер.

**Пример 5: Бесконечный опрос пользователя**

Программа постоянно запрашивает у пользователя команды до тех пор, пока не будет введена команда "выход".
"""

while True:
    command = input("Введите команду (или 'выход' для завершения):\n>>> ")
    if command.lower() == "выход":
        print("Завершение программы.")
        break
    print("Вы ввели команду:", command)

"""### 4.5. Примеры использования

**Пример 6: Игра "Угадай число"**

Программа загадывает число от 1 до 100 и позволяет пользователю пытаться его угадать. Цикл продолжается до тех пор, пока пользователь не угадает число.

"""

import random

secret_number = random.randint(1, 100)
guess = None

while guess != secret_number:
    guess = int(input("Угадайте число от 1 до 100:\n>>> "))
    if guess < secret_number:
        print("Слишком маленькое число. Попробуйте ещё раз.")
    elif guess > secret_number:
        print("Слишком большое число. Попробуйте ещё раз.")
    else:
        print("Поздравляем! Вы угадали число.")

"""### Заключение

Цикл `while` является мощным инструментом для выполнения повторяющихся задач, особенно когда количество итераций заранее неизвестно. Понимание синтаксиса, управления циклом с помощью счётчиков и операторов `break` и `continue` позволяет создавать гибкие и эффективные программы. Важно также уметь контролировать условия завершения цикла, чтобы избежать бесконечных циклов, если это не требуется по логике программы.

---

## 5. Работа с циклом `for`

Цикл `for` позволяет перебрать элементы последовательности (например, список, строку, диапазон чисел) и выполнить блок кода для каждого элемента. В отличие от цикла `while`, цикл `for` обычно используется, когда количество итераций заранее известно или определяется размером перебираемой последовательности.

### 5.1. Синтаксис цикла `for`

Цикл `for` состоит из ключевого слова `for`, переменной цикла, ключевого слова `in` и объекта перебора (например, списка или диапазона). Блок кода внутри цикла выполняется для каждого элемента последовательности.

**Пример 1: Перебор элементов списка**
"""

fruits = ["яблоко", "банан", "вишня"]

for fruit in fruits:
    print(fruit)

"""
**Пример 2: Перебор символов строки**
"""

word = "программирование"

for letter in word:
    print(letter)

"""
### 5.2. Использование функции `range()`

Функция `range()` генерирует последовательность чисел, которая часто используется вместе с циклом `for` для выполнения определённого количества итераций.

**Структура функции `range()`:**

```python
range(stop)
range(start, stop[, step])
```

- `start` — начальное значение (включительно).
- `stop` — конечное значение (исключая).
- `step` — шаг (по умолчанию 1).

**Пример 3: Итерация с использованием `range()`**
"""

# Перебор чисел от 0 до 4
for i in range(5):
    print(i)

"""
**Пример 4: Итерация с заданным шагом**
"""

# Перебор чисел от 10 до 20 с шагом 2
for i in range(10, 21, 2):
    print(i)

"""
### 5.3. Итерация по различным типам данных

Цикл `for` может использоваться для перебора различных типов данных, включая строки, списки, кортежи и другие итерируемые объекты.

**Пример 5: Итерация по списку чисел**"""

numbers = [1, 2, 3, 4, 5]

for number in numbers:
    print("Число:", number)

"""
**Пример 6: Итерация по кортежу**"""

coordinates = (10, 20, 30)

for coord in coordinates:
    print("Координата:", coord)

"""
### 5.4. Операторы `break` и `continue` в цикле `for`

Как и в цикле `while`, операторы `break` и `continue` позволяют управлять потоком выполнения внутри цикла `for`.

- `break` — полностью прерывает выполнение цикла.
- `continue` — пропускает текущую итерацию и переходит к следующей.

**Пример 7: Прерывание цикла при нахождении элемента**
"""

search_item = input("Введите элемент для поиска:\n>>> ")
items = ["яблоко", "банан", "вишня", "груша"]

for item in items:
    if item == search_item:
        print(f"Элемент '{search_item}' найден.")
        break

"""
**Пример 8: Пропуск нечётных чисел**
"""

for i in range(1, 11):
    if i % 2 != 0:
        continue
    print(f"{i} — чётное число")

"""
### 5.5. Примеры использования

**Пример 9: Вычисление суммы чисел**
"""

count = int(input("Сколько чисел вы хотите ввести?\n>>> "))
total_sum = 0

for _ in range(count):
    number = float(input("Введите число:\n>>> "))
    total_sum += number

print("Сумма введённых чисел:", total_sum)

"""
**Пример 10: Обработка элементов списка**
"""

names = ["Анна", "Борис", "Виктор", "Галина"]

for name in names:
    print(f"Привет, {name}!")

"""## 5.6. Использование `else` с циклами

В Python конструкция `else` может быть использована вместе с циклами `for` и `while`. Блок кода внутри `else` выполняется, когда цикл завершается естественным образом, то есть не был прерван оператором `break`. Это полезно для выполнения действий после завершения цикла, например, когда элемент не был найден в перебираемой последовательности.

### Структура использования `else` с циклами

```python
for элемент in последовательность:
    # Блок кода цикла
    if условие:
        break
else:
    # Блок кода выполняется, если цикл завершился без break
    действие
```

```python
while условие:
    # Блок кода цикла
    if другое_условие:
        break
else:
    # Блок кода выполняется, если цикл завершился без break
    действие
```
"""

search_item = input("Введите элемент для поиска:\n>>> ")
items = ["яблоко", "банан", "вишня", "груша"]

for item in items:
    if item == search_item:
        print(f"Элемент '{search_item}' найден.")
        break
else:
    print(f"Элемент '{search_item}' не найден.")

"""
**Объяснение:**

- Цикл перебирает каждый элемент в списке `items`.
- Если текущий `item` совпадает с `search_item`, выводится сообщение о нахождении элемента, и цикл прерывается.
- Если цикл завершился без нахождения элемента (т.е. без выполнения `break`), выполняется блок `else`, выводя сообщение о ненахождении элемента.

### Пример 2: Проверка простого числа

Программа запрашивает у пользователя число и проверяет, является ли оно простым. Если делитель найден (т.е. число не простое), цикл прерывается. Если делители не найдены после проверки всех возможных делителей, число считается простым, и выполняется блок `else`.
"""

number = int(input("Введите число для проверки на простоту:\n>>> "))

if number > 1:
    for i in range(2, number):
        if number % i == 0:
            print(f"Число {number} не является простым, так как делится на {i}.")
            break
    else:
        print(f"Число {number} является простым.")
else:
    print("Простые числа больше 1.")

"""
**Объяснение:**

- Если введённое число больше 1, начинается цикл для проверки делимости числа.
- Если находится делитель, выводится сообщение о том, что число не простое, и цикл прерывается.
- Если цикл завершается без нахождения делителя, выполняется блок `else`, подтверждая, что число простое.
- Для чисел меньше или равных 1 выводится соответствующее сообщение.

### Пример 3: Поиск отсутствующего числа

Предположим, у нас есть список чисел от 1 до 10, но одно число отсутствует. Программа должна найти и вывести отсутствующее число. Если все числа на месте, выполняется блок `else`.
"""

expected_numbers = list(range(1, 11))
actual_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 10]  # Число 9 отсутствует

for num in expected_numbers:
    if num not in actual_numbers:
        print(f"Отсутствует число: {num}")
        break
else:
    print("Все числа на месте.")

"""
**Объяснение:**

- Цикл перебирает все ожидаемые числа от 1 до 10.
- Если текущее число отсутствует в списке `actual_numbers`, выводится сообщение о его отсутствии, и цикл прерывается.
- Если все числа присутствуют, выполняется блок `else`, подтверждая полноту списка.

### Пример 4: Проверка доступности сервера

Программа пытается подключиться к серверу до тех пор, пока соединение не будет установлено или количество попыток не достигнет лимита. Если соединение не удалось после всех попыток, выполняется блок `else`.
"""

max_attempts = 5
attempt = 0

while attempt < max_attempts:
    response = input("Попытка подключения к серверу (успех/неудача):\n>>> ")
    if response.lower() == "успех":
        print("Соединение установлено.")
        break
    else:
        print("Попытка не удалась. Повторяем...")
        attempt += 1
else:
    print("Не удалось подключиться к серверу после нескольких попыток.")

"""**Объяснение:**

- Цикл выполняется до тех пор, пока количество попыток меньше `max_attempts`.
- Если пользователь вводит "успех", выводится сообщение об успешном подключении, и цикл прерывается.
- В противном случае увеличивается счётчик попыток и выводится сообщение о неудачной попытке.
- Если все попытки исчерпаны без успешного подключения, выполняется блок `else`.

### Заключение

Цикл `for` является мощным инструментом для перебора элементов различных последовательностей и выполнения повторяющихся задач. Понимание синтаксиса, использования функции `range()`, итерации по различным типам данных, а также управление потоком с помощью операторов `break` и `continue` позволяет эффективно использовать цикл `for` в ваших программах. Практическое применение этих знаний поможет вам создавать более гибкие и функциональные приложения.

## 6. Вложенные циклы

Вложенные циклы позволяют создавать более сложные логические структуры, выполняя одну итерацию цикла внутри другой. Это полезно при работе с многомерными данными, такими как двумерные массивы, таблицы или при выполнении сложных вычислений, требующих нескольких уровней повторений.

### 6.1. Понятие вложенных циклов

**Вложенный цикл** — это цикл, который находится внутри другого цикла. Внешний цикл управляет количеством повторений, а вложенный цикл выполняет действия для каждой итерации внешнего цикла.

**Структура вложенных циклов:**

```python
for элемент_внешнего_цикла in внешняя_последовательность:
    # Блок кода внешнего цикла
    for элемент_внутреннего_цикла in внутренняя_последовательность:
        # Блок кода внутреннего цикла
        действие
```

### 6.2. Синтаксис и структура

Вложенные циклы могут быть как `for` внутри `for`, так и комбинацией `for` и `while`. Важно правильно организовать отступы и логику, чтобы избежать ошибок и обеспечить корректное выполнение программы.

**Пример 1: Создание таблицы умножения**

Этот пример демонстрирует использование вложенных циклов `for` для создания таблицы умножения от 1 до 5.
"""

print("Таблица умножения от 1 до 5:")

for i in range(1, 6):
    for j in range(1, 6):
        print(f"{i} * {j} = {i * j}")
    print("-" * 20)  # Разделитель между рядами таблицы

"""
**Объяснение:**

- Внешний цикл перебирает числа от 1 до 5 (переменная `i`).
- Внутренний цикл перебирает числа от 1 до 5 для каждого значения `i` (переменная `j`).
- Для каждой пары `(i, j)` вычисляется произведение и выводится на экран.
- После завершения внутреннего цикла выводится разделитель для улучшения читаемости таблицы.

### 6.3. Примеры использования

**Пример 2: Обработка двумерного списка (матрицы)**

Предположим, у нас есть двумерный список, представляющий матрицу. Необходимо пройтись по всем элементам матрицы и вывести их.
"""

rows = int(input("Введите количество строк матрицы:\n>>> "))
cols = int(input("Введите количество столбцов матрицы:\n>>> "))

matrix = []

# Ввод элементов матрицы пользователем
for i in range(rows):
    row = []
    for j in range(cols):
        element = input(f"Введите элемент [{i + 1}][{j + 1}]:\n>>> ")
        row.append(element)
    matrix.append(row)

print("\nВведённая матрица:")
for row in matrix:
    for element in row:
        print(element, end="\t")
    print()  # Переход на новую строку после каждой строки матрицы

"""
**Объяснение:**

- Пользователь вводит количество строк и столбцов матрицы.
- Внешний цикл `for` проходит по каждой строке.
- Внутренний цикл `for` проходит по каждому столбцу в текущей строке, запрашивая ввод элемента.
- Все элементы собираются в двумерный список `matrix`.
- После ввода элементов матрица выводится на экран в структурированном виде.

**Пример 3: Рисование фигур в консоли (пирамида из звёздочек)**

Этот пример показывает, как с помощью вложенных циклов можно нарисовать пирамиду из символов `*`.
"""

height = int(input("Введите высоту пирамиды:\n>>> "))

for i in range(1, height + 1):
    # Вывод пробелов для выравнивания пирамиды по центру
    for _ in range(height - i):
        print(" ", end="")
    # Вывод звёздочек
    for _ in range(2 * i - 1):
        print("*", end="")
    print()  # Переход на новую строку после каждой строки пирамиды

"""
**Объяснение:**

- Пользователь вводит высоту пирамиды.
- Внешний цикл `for` отвечает за количество уровней пирамиды.
- Первый вложенный цикл выводит пробелы для выравнивания текущего уровня по центру.
- Второй вложенный цикл выводит необходимое количество звёздочек для текущего уровня.
- После вывода каждой строки пирамиды происходит переход на новую строку.

**Пример 4*: Обработка двумерного массива чисел (сумма всех элементов)**

Программа запрашивает у пользователя размеры двумерного массива, затем вводит элементы и вычисляет их сумму.
"""

rows = int(input("Введите количество строк массива:\n>>> "))
cols = int(input("Введите количество столбцов массива:\n>>> "))

matrix = []
total_sum = 0

# Ввод элементов массива и подсчёт суммы
for i in range(rows):
    row = []
    for j in range(cols):
        element = float(input(f"Введите элемент [{i + 1}][{j + 1}]:\n>>> "))
        row.append(element)
        total_sum += element
    matrix.append(row)

print("\nВведённый массив:")
for row in matrix:
    for element in row:
        print(element, end="\t")
    print()

print(f"\nСумма всех элементов массива: {total_sum}")

"""**Объяснение:**

- Пользователь вводит количество строк и столбцов массива.
- Внешний цикл `for` проходит по каждой строке.
- Внутренний цикл `for` запрашивает ввод каждого элемента массива и добавляет его к текущей строке и общей сумме.
- После ввода всех элементов массив выводится на экран, а также отображается сумма всех элементов.

### Заключение

Вложенные циклы являются мощным инструментом для работы с многомерными структурами данных и выполнения сложных повторяющихся задач. Они позволяют эффективно обрабатывать двумерные массивы, рисовать сложные фигуры, выполнять многослойные вычисления и многое другое. Важно внимательно следить за структурой вложенных циклов и правильным использованием отступов, чтобы избежать ошибок и обеспечить читаемость кода.

## 7. Дополнительные примеры

Попробуйте решить задачи самостоятельно, ответы будут в конце раздела.

### 7.1. Задача на оператор `if`

**Определение, является ли число положительным, отрицательным или нулём.**

Напишите программу, которая запрашивает у пользователя число и определяет, является ли оно положительным, отрицательным или нулём.

### 7.2. Задача на логические операции

**Проверка наличия гласных и согласных в слове.**

Напишите программу, которая запрашивает у пользователя слово и проверяет, содержит ли оно гласные, согласные или и то, и другое.

### 7.3. Задача на цикл `while`

**Система регистрации пользователей с ограничением по количеству попыток.**

Создайте программу, которая позволяет пользователю попытаться зарегистрироваться, вводя правильный пароль. У пользователя есть ограниченное количество попыток (например, 3). Если пользователь вводит правильный пароль, выводится сообщение об успешной регистрации. Если попытки исчерпаны, выводится сообщение о блокировке.

### 7.4. Задача на цикл `for`

**Подсчёт суммы чётных и нечётных чисел в диапазоне.**

Напишите программу, которая запрашивает у пользователя два числа, определяющих диапазон, и вычисляет сумму всех чётных и нечётных чисел в этом диапазоне.

### 7.5. Задача с вложенными циклами

**Создание шахматной доски.**

Напишите программу, которая выводит на экран шахматную доску заданного размера (например, 8x8), используя символы `#` и пробелы для обозначения чёрных и белых клеток.

##  Ответы

**Задача 1**
"""

# Определение, является ли число положительным, отрицательным или нулём

number = float(input("Введите число:\n>>> "))

if number > 0:
    print("Число положительное.")
elif number < 0:
    print("Число отрицательное.")
else:
    print("Число равно нулю.")

"""**Задача 2**"""

# Проверка наличия гласных и согласных в слове

word = input("Введите слово:\n>>> ").lower()

vowels = "аеёиоуыэюя"
has_vowel = False
has_consonant = False

for letter in word:
    if letter in vowels:
        has_vowel = True
    elif letter.isalpha():
        has_consonant = True

if has_vowel and has_consonant:
    print("Слово содержит как гласные, так и согласные буквы.")
elif has_vowel:
    print("Слово содержит только гласные буквы.")
elif has_consonant:
    print("Слово содержит только согласные буквы.")
else:
    print("Слово не содержит букв.")

"""**Задача 3**"""

# Система регистрации пользователей с ограничением по количеству попыток

correct_password = "password123"
max_attempts = 3
attempt = 0
authenticated = False

while attempt < max_attempts:
    entered_password = input("Введите пароль:\n>>> ")
    if entered_password == correct_password:
        print("Регистрация успешна! Добро пожаловать.")
        authenticated = True
        break
    else:
        attempt += 1
        remaining_attempts = max_attempts - attempt
        if remaining_attempts > 0:
            print(f"Неверный пароль. Осталось попыток: {remaining_attempts}")
        else:
            print("Попытки исчерпаны. Доступ заблокирован.")

if not authenticated:
    print("Попробуйте позже.")

"""**Задача 4**"""

# Подсчёт суммы чётных и нечётных чисел в диапазоне

start = int(input("Введите начальное число диапазона:\n>>> "))
end = int(input("Введите конечное число диапазона:\n>>> "))

sum_even = 0
sum_odd = 0

for number in range(start, end + 1):
    if number % 2 == 0:
        sum_even += number
    else:
        sum_odd += number

print(f"Сумма чётных чисел: {sum_even}")
print(f"Сумма нечётных чисел: {sum_odd}")

"""**Задача 5**"""

# Создание шахматной доски

size = int(input("Введите размер шахматной доски:\n>>> "))

for row in range(size):
    line = ""
    for col in range(size):
        if (row + col) % 2 == 0:
            line += "# "
        else:
            line += "  "
    print(line)

"""Усложненный пример с нумерацией строк и столбцов:"""

# Создание шахматной доски с нумерацией строк и столбцов

size = 8  # Стандартный размер шахматной доски

print("  " + " ".join(str(i) for i in range(1, size + 1)))  # Нумерация столбцов

for row in range(size):
    line = str(row + 1) + " "  # Нумерация строк
    for col in range(size):
        if (row + col) % 2 == 0:
            line += "# "
        else:
            line += "  "
    print(line)

"""### Заключение

Выполнение практических заданий позволяет закрепить теоретические знания и развить навыки программирования. Постарайтесь самостоятельно решить каждую задачу, а затем сравнить свой код с приведёнными примерами. Если возникнут сложности, обратитесь к изученному материалу или задайте вопросы на занятии.

## 8. Тонкости использования операторов ветвления и циклов

В процессе разработки программ часто возникают ситуации, требующие внимательного подхода к использованию операторов ветвления и циклов. В этом разделе мы рассмотрим распространённые ошибки, способы оптимизации циклов и лучшие практики написания кода для повышения его читаемости и эффективности.

### 8.1. Частые ошибки и их предотвращение

#### Неправильное использование отступов

В Python отступы играют ключевую роль в определении блоков кода. Неправильные отступы могут привести к синтаксическим ошибкам или некорректному выполнению программы.

**Пример 1: Ошибка отступов в операторе `if`**
"""

# Неправильные отступы приведут к ошибке синтаксиса
age = int(input("Введите ваш возраст:\n>>> "))

if age >= 18:
print("Вы совершеннолетний.")
else:
    print("Вы ещё не совершеннолетний.")

"""
**Исправление:**
"""

# Правильные отступы обеспечивают корректное выполнение кода
age = int(input("Введите ваш возраст:\n>>> "))

if age >= 18:
    print("Вы совершеннолетний.")
else:
    print("Вы ещё не совершеннолетний.")

"""
#### Логические ошибки в условиях

Логические ошибки возникают, когда условие написано неправильно, что приводит к неожиданному поведению программы.

**Пример 2: Неправильное условие для проверки диапазона**
"""

# Ошибка: условие всегда истинно, так как число не может одновременно быть меньше 5 и больше 10
number = int(input("Введите число:\n>>> "))

if number < 5 and number > 10:
    print("Число находится вне диапазона 5-10.")
else:
    print("Число находится в диапазоне 5-10.")

"""
**Исправление:**
"""

# Правильное условие с использованием оператора `or`
number = int(input("Введите число:\n>>> "))

if number < 5 or number > 10:
    print("Число находится вне диапазона 5-10.")
else:
    print("Число находится в диапазоне 5-10.")

"""
### 8.2. Оптимизация циклов

Оптимизация циклов позволяет повысить производительность программы, снизить использование ресурсов и улучшить читаемость кода.

#### Избегание лишних итераций

Часто циклы выполняют больше итераций, чем необходимо. Оптимизация заключается в сокращении количества повторений за счёт раннего выхода из цикла или правильной постановки условий.

**Пример 3: Оптимизация поиска элемента в списке**
"""

# Неоптимизированный цикл: проходит все элементы, даже после нахождения нужного
items = [1, 2, 3, 4, 5]
search = int(input("Введите число для поиска:\n>>> "))

found = False
for item in items:
    if item == search:
        found = True
print("Число найдено." if found else "Число не найдено.")

"""
**Оптимизированный цикл с использованием `break`:**
"""

# Оптимизированный цикл: прерывается после нахождения элемента
items = [1, 2, 3, 4, 5]
search = int(input("Введите число для поиска:\n>>> "))

found = False
for item in items:
    if item == search:
        found = True
        break
print("Число найдено." if found else "Число не найдено.")

"""
#### Эффективность алгоритмов

Выбор правильного алгоритма и структуры данных может существенно повлиять на эффективность программы. Например, использование множества (`set`) для поиска элементов быстрее, чем список (`list`).

**Пример 4: Сравнение скорости поиска в списке и множестве**
"""

import time

# Создание большого списка и множества
large_list = list(range(1000000))
large_set = set(large_list)

search_item = int(input("Введите число для поиска:\n>>> "))

# Поиск в списке
start_time = time.time()
found = search_item in large_list
list_time = time.time() - start_time

# Поиск в множестве
start_time = time.time()
found = search_item in large_set
set_time = time.time() - start_time

print(f"Время поиска в списке: {list_time:.6f} секунд.")
print(f"Время поиска в множестве: {set_time:.6f} секунд.")

"""``

### 8.3. Лучшие практики

#### Читаемость кода

Читаемость кода облегчает его понимание и поддержку. Используйте понятные имена переменных, структурируйте код логически и избегайте излишней сложности.

**Пример 5: Плохая читаемость кода**

"""

a = 10
b = 20
c = a + b
print(c)

"""
**Улучшенная читаемость:**
"""

first_number = 10
second_number = 20
sum_of_numbers = first_number + second_number
print(sum_of_numbers)

"""
#### Комментирование и документация

Комментарии помогают другим разработчикам (и вам самим в будущем) понять, что делает тот или иной участок кода. Используйте комментарии для объяснения сложных логических частей или важных решений.

**Пример 6: Комментированный код**
"""

# Запрашиваем у пользователя количество элементов
count = int(input("Введите количество элементов списка:\n>>> "))

elements = []
for _ in range(count):
    # Добавляем введённый элемент в список
    element = input("Введите элемент:\n>>> ")
    elements.append(element)

# Выводим все элементы списка
print("Введённые элементы:", elements)

"""### Заключение

Тонкости использования операторов ветвления и циклов играют важную роль в создании эффективного и надёжного кода. Избегая распространённых ошибок, оптимизируя циклы и следуя лучшим практикам, вы сможете писать более качественные программы, которые будут легко поддерживаться и масштабироваться.

## 9. Заключение

### 9.1. Подведение итогов

В ходе занятия «Управление потоком» вы изучили основные конструкции, позволяющие контролировать выполнение программы:

- **Операторы ветвления**: `if`, `elif`, `else` — для принятия решений на основе условий.
- **Логические операторы**: `and`, `or`, `not` — для создания сложных условий.
- **Циклы**: `while` и `for` — для повторения действий и перебора элементов.
- **Вложенные циклы** — для создания многослойных структур, таких как двумерные массивы и графические фигуры.
- **Тонкости использования**: распространённые ошибки, оптимизация циклов, лучшие практики написания читаемого и эффективного кода.

Вы также выполнили практические задания, что позволило закрепить полученные знания на практике.

---


Спасибо за внимание! Продолжайте практиковаться, решайте дополнительные задачи и применяйте изученные конструкции в своих проектах. Если возникнут вопросы или потребуется дополнительная помощь, обращайтесь на занятии или используйте доступные ресурсы для самостоятельного изучения.

Удачи в дальнейших занятиях и успехов в программировании!
"""